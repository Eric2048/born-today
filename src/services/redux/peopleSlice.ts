
import { createSlice, createAsyncThunk, createSelector, createEntityAdapter } from '@reduxjs/toolkit'

//-----------------------------------------------------------------------------
// Services
import type { RootState } from './store';
import { getPeople }      from '../WikimediaService';

//-----------------------------------------------------------------------------
// Models
import type { Person } from '../../models/Person';

//-----------------------------------------------------------------------------
// Constants & Types

// This EntityAdapter will provide a set of reducers and selectors for this data type.
// A Person record's unique id in its 'id' property so no need to specify 'selectId' here.
const peopleAdapter = createEntityAdapter<Person>({
  // This is used to keep the entity's state.id array in our preferred sorted order.
  sortComparer: (person1: Person, person2: Person) => (person1.year || 0) - (person2.year || 0)
})

export const enum PeopleStatus {
  Idle      = "idle",
  Loading   = "loading",
  Failed    = "failed",
  Succeeded = "succeeded"
}

const initialState = peopleAdapter.getInitialState({
  status: PeopleStatus.Idle,
  error:  ''
});

// Create an async action to fetch the data
export const fetchPeople = createAsyncThunk(
  // type (prefix for the action types which are created, e.g. 'people/fetchPeople/fulfilled')
  'people/fetchPeople',

  // payloadCreator
  async (arg: { month: string, day: string }) => {
    const { month, day } = arg;

    // Call our WikimediaService to issue the request
    return await getPeople({ month, day });
  },

  // options
  {
    // Add a 'Cancel before execution' condition, to ensure we don't send a duplicate request.
    // This is important for React 18+, see comments in the calling component's useEffect().
    // See: https://redux-toolkit.js.org/api/createAsyncThunk#canceling-before-execution
    condition: (_arg, { getState }) => {
      const proceed = (getState() as RootState).people.status !== PeopleStatus.Loading;
      // if (!proceed) console.log(`peopleSlice: cancelling fetchPeople action`, (getState() as RootState).people.status);
      return (proceed);
    }
  }
);

const peopleSlice = createSlice({
  name: 'people',
  
  initialState,

  // No reducers at this point (we are not mutating this data).
  // When adding those, note that peopleAdapter can provide common action types and reducers.
  // See: https://redux-toolkit.js.org/api/createEntityAdapter
  reducers: {
    resetState: () => {
      return initialState;
    }
  },

  // Define additional actions generated by createAsyncThunk,
  // specifically those indicating the result of the fetch operation.
  extraReducers(builder) {
    builder
      .addCase(
        // action (from createAsyncThunk(), see above)
        fetchPeople.pending,
        // reducer
        (state) => {
          state.status = PeopleStatus.Loading;
        }
      )
      .addCase(fetchPeople.fulfilled, (state, action) => {
        state.status = PeopleStatus.Succeeded;

        // Replace our entire list
        peopleAdapter.setAll(state, action.payload);
      })
      .addCase(fetchPeople.rejected, (state, action) => {
        state.status = PeopleStatus.Failed;
        state.error = action.error.message || 'Undefined error'
      })
  },
})

// Export our reducers
export const { resetState } = peopleSlice.actions

// Export this slice's reducer as our default.
export default peopleSlice.reducer;

// Return a series of globalized selectors that can be used to access people data.
// See: https://redux-toolkit.js.org/api/createEntityAdapter#selector-functions
export const {
  selectAll:  selectAllPeople,
  selectById: selectPersonById,
  selectIds:  selectPeopleIds,
} = peopleAdapter.getSelectors<RootState>((state) => state.people);

// Provide a memoized selector to extract this property.
export const selectPeopleStatus = createSelector(
  [
    // Input selector: this selector is only re-defined if this result changes
    (state) => state.people,
  ],
  // Output selector: takes the result from above and transforms it to the property we are seeking.
  (people) => people.status
);
